THREE.CopyShader={uniforms:{tDiffuse:{type:"t",value:null},opacity:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","gl_FragColor = opacity * texel;","}"].join("\n")},THREE.DoFShader={uniforms:{tDiffuse:{type:"t",value:null},tDepth:{type:"t",value:null},znear:{type:"f",value:1},zfar:{type:"f",value:1e3},size:{type:"v2",value:new THREE.Vector2(512,512)},textel:{type:"v2",value:new THREE.Vector2(1/512,1/512)},focalDepth:{type:"f",value:200},focalLength:{type:"f",value:28},fstop:{type:"f",value:2.8},showFocus:{type:"i",value:0},manualdof:{type:"i",value:0},ndofstart:{type:"f",value:1},ndofdist:{type:"f",value:2},fdofstart:{type:"f",value:1},fdofdist:{type:"f",value:3},CoC:{type:"f",value:.03},vignetting:{type:"i",value:1},vignout:{type:"f",value:1.3},vignin:{type:"f",value:0},vignfade:{type:"f",value:22},autofocus:{type:"i",value:1},focus:{type:"v2",value:new THREE.Vector2(.5,.5)},maxblur:{type:"f",value:1},threshold:{type:"f",value:.8},gain:{type:"f",value:1.7},bias:{type:"f",value:.5},fringe:{type:"f",value:.7},noise:{type:"i",value:1},namount:{type:"f",value:1e-4},depthblur:{type:"i",value:0},dbsize:{type:"f",value:1.25}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["precision mediump float;","#define PI  3.14159265","varying vec2 vUv;","uniform sampler2D tDiffuse;","uniform sampler2D tDepth;","uniform vec2 size;","uniform vec2 texel;","uniform float focalDepth;","uniform float focalLength;","uniform float fstop;","uniform bool showFocus;","uniform float znear;","uniform float zfar;","uniform bool manualdof;","uniform float ndofstart;","uniform float ndofdist;","uniform float fdofstart;","uniform float fdofdist;","uniform float CoC;","uniform bool vignetting;","uniform float vignout;","uniform float vignin;","uniform float vignfade;","uniform bool autofocus;","uniform vec2 focus;","uniform float maxblur;","uniform float threshold;","uniform float gain;","uniform float bias;","uniform float fringe;","uniform bool noise;","uniform float namount;","uniform bool depthblur;","uniform float dbsize;","int samples = 3;","const int rings = 3;","bool pentagon = false;","float feather = 0.4;","float unpackDepth( const in vec4 rgba_depth ) {","const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );","float depth = dot( rgba_depth, bit_shift );","return depth;","}","float penta(vec2 coords)","{","float scale = float(rings) - 1.3;","vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);","vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);","vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);","vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);","vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);","vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);","vec4  one = vec4( 1.0 );","vec4 P = vec4((coords),vec2(scale, scale));","vec4 dist = vec4(0.0);","float inorout = -4.0;","dist.x = dot( P, HS0 );","dist.y = dot( P, HS1 );","dist.z = dot( P, HS2 );","dist.w = dot( P, HS3 );","dist = smoothstep( -feather, feather, dist );","inorout += dot( dist, one );","dist.x = dot( P, HS4 );","dist.y = HS5.w - abs( P.z );","dist = smoothstep( -feather, feather, dist );","inorout += dist.x;","return clamp( inorout, 0.0, 1.0 );","}","float bdepth(vec2 coords) //blurring depth","{","float d = 0.0;","float kernel[9];","vec2 offset[9];","vec2 wh = vec2(texel.x, texel.y) * dbsize;","offset[0] = vec2(-wh.x,-wh.y);","offset[1] = vec2( 0.0, -wh.y);","offset[2] = vec2( wh.x -wh.y);","offset[3] = vec2(-wh.x,  0.0);","offset[4] = vec2( 0.0,   0.0);","offset[5] = vec2( wh.x,  0.0);","offset[6] = vec2(-wh.x, wh.y);","offset[7] = vec2( 0.0,  wh.y);","offset[8] = vec2( wh.x, wh.y);","kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;","kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;","kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;","for( int i=0; i<9; i++ )","{","float tmp = unpackDepth(texture2D(tDepth, coords + offset[i]));","d += tmp * kernel[i];","}","return d;","}","vec3 color(vec2 coords,float blur)","{","vec3 col = vec3(0.0);","col.r = texture2D(tDiffuse,coords + vec2(0.0,1.0)*texel*fringe*blur).r;","col.g = texture2D(tDiffuse,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;","col.b = texture2D(tDiffuse,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;","vec3 lumcoeff = vec3(0.299,0.587,0.114);","float lum = dot(col.rgb, lumcoeff);","float thresh = max((lum-threshold)*gain, 0.0);","return col+mix(vec3(0.0),col,thresh*blur);","}","vec2 rand(vec2 coord) //generating noise/pattern texture for dithering","{","float noiseX = ((fract(1.0-coord.s*(size.x/2.0))*0.25)+(fract(coord.t*(size.y/2.0))*0.75))*2.0-1.0;","float noiseY = ((fract(1.0-coord.s*(size.x/2.0))*0.75)+(fract(coord.t*(size.y/2.0))*0.25))*2.0-1.0;","if (noise)","{","noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;","noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;","}","return vec2(noiseX,noiseY);","}","vec3 debugFocus(vec3 col, float blur, float depth)","{","float edge = 0.002*depth; //distance based edge smoothing","float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);","float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);","col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);","col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);","return col;","}","float linearize(float depth)","{","return -zfar * znear / (depth * (zfar - znear) - zfar);","}","float vignette()","{","float dist = distance(vUv, vec2(0.5,0.5));","dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);","return clamp(dist,0.0,1.0);","}","void main()","{","float depth = linearize(unpackDepth(texture2D(tDepth,vUv)));","if (depthblur)","{","depth = linearize(bdepth(vUv));","}","float fDepth = focalDepth;","if (autofocus)","{","fDepth = linearize(unpackDepth(texture2D(tDepth,focus)));","}","float blur = 0.0;","if (manualdof)","{","float a = depth-fDepth;","float b = (a-fdofstart)/fdofdist;","float c = (-a-ndofstart)/ndofdist;","blur = (a>0.0)?b:c;","}","else","{","float f = focalLength;","float d = fDepth*1000.0;","float o = depth*1000.0;","float a = (o*f)/(o-f);","float b = (d*f)/(d-f);","float c = (d-f)/(d*fstop*CoC);","blur = abs(a-b)*c;","}","blur = clamp(blur,0.0,1.0);","vec2 noise = rand(vUv)*namount*blur;","float w = (1.0/size.x)*blur*maxblur+noise.x;","float h = (1.0/size.y)*blur*maxblur+noise.y;","vec3 col = vec3(0.0);","if(blur < 0.05)","{","col = texture2D(tDiffuse, vUv).rgb;","}","else","{","col = texture2D(tDiffuse, vUv).rgb;","float s = 1.0;","for (int i = 1; i <= rings; i += 1)","{","float ringsamples = float(i * samples);","if(i == 1)","{","for (int j = 0 ; j < 3 ; j += 1)","{","float step = PI*2.0 / float(ringsamples);","float pw = (cos(float(j)*step)*float(i));","float ph = (sin(float(j)*step)*float(i));","float p = 1.0;","if (pentagon)","{","p = penta(vec2(pw,ph));","}","col += color(vUv + vec2(pw*w,ph*h),blur)*mix(1.0,(float(i))/(float(rings)),bias)*p;","s += 1.0*mix(1.0,(float(i))/(float(rings)),bias)*p;","}","}","else if(i == 2)","{","for (int j = 0 ; j < 6 ; j += 1)","{","float step = PI*2.0 / float(ringsamples);","float pw = (cos(float(j)*step)*float(i));","float ph = (sin(float(j)*step)*float(i));","float p = 1.0;","if (pentagon)","{","p = penta(vec2(pw,ph));","}","col += color(vUv + vec2(pw*w,ph*h),blur)*mix(1.0,(float(i))/(float(rings)),bias)*p;","s += 1.0*mix(1.0,(float(i))/(float(rings)),bias)*p;","}","}","else if(i == 3)","{","for (int j = 0 ; j < 9 ; j += 1)","{","float step = PI*2.0 / float(ringsamples);","float pw = (cos(float(j)*step)*float(i));","float ph = (sin(float(j)*step)*float(i));","float p = 1.0;","if (pentagon)","{","p = penta(vec2(pw,ph));","}","col += color(vUv + vec2(pw*w,ph*h),blur)*mix(1.0,(float(i))/(float(rings)),bias)*p;","s += 1.0*mix(1.0,(float(i))/(float(rings)),bias)*p;","}","}","}","col /= s;","}","if (showFocus)","{","col = debugFocus(col, blur, depth);","}","if (vignetting)","{","col *= vignette();","}","gl_FragColor.rgb = col;","gl_FragColor.a = 1.0;","}"].join("\n")},THREE.EffectComposer=function(e,t){if(this.renderer=e,void 0===t){var o=window.innerWidth||1,r=window.innerHeight||1,i={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBFormat,stencilBuffer:!1};t=new THREE.WebGLRenderTarget(o,r,i)}this.renderTarget1=t,this.renderTarget2=t.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.passes=[],void 0===THREE.CopyShader&&console.error("THREE.EffectComposer relies on THREE.CopyShader"),this.copyPass=new THREE.ShaderPass(THREE.CopyShader)},THREE.EffectComposer.prototype={swapBuffers:function(){var e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e},addPass:function(e){this.passes.push(e)},insertPass:function(e,t){this.passes.splice(t,0,e)},render:function(e){this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2;var t,o,r=!1,i=this.passes.length;for(o=0;i>o;o++)if(t=this.passes[o],t.enabled){if(t.render(this.renderer,this.writeBuffer,this.readBuffer,e,r),t.needsSwap){if(r){var a=this.renderer.context;a.stencilFunc(a.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),a.stencilFunc(a.EQUAL,1,4294967295)}this.swapBuffers()}t instanceof THREE.MaskPass?r=!0:t instanceof THREE.ClearMaskPass&&(r=!1)}},reset:function(e){void 0===e&&(e=this.renderTarget1.clone(),e.width=window.innerWidth,e.height=window.innerHeight),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2},setSize:function(e,t){var o=this.renderTarget1.clone();o.width=e,o.height=t,this.reset(o)}},THREE.FXAAShader={uniforms:{tDiffuse:{type:"t",value:null},resolution:{type:"v2",value:new THREE.Vector2(1/1024,1/512)}},vertexShader:["void main() {","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform vec2 resolution;","#define FXAA_REDUCE_MIN   (1.0/128.0)","#define FXAA_REDUCE_MUL   (1.0/8.0)","#define FXAA_SPAN_MAX     8.0","void main() {","vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;","vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;","vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;","vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;","vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );","vec3 rgbM  = rgbaM.xyz;","vec3 luma = vec3( 0.299, 0.587, 0.114 );","float lumaNW = dot( rgbNW, luma );","float lumaNE = dot( rgbNE, luma );","float lumaSW = dot( rgbSW, luma );","float lumaSE = dot( rgbSE, luma );","float lumaM  = dot( rgbM,  luma );","float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );","float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );","vec2 dir;","dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));","dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));","float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );","float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );","dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),","max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),","dir * rcpDirMin)) * resolution;","vec4 rgbA = (1.0/2.0) * (","texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +","texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));","vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (","texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +","texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));","float lumaB = dot(rgbB, vec4(luma, 0.0));","if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {","gl_FragColor = rgbA;","} else {","gl_FragColor = rgbB;","}","}"].join("\n")},THREE.MaskPass=function(e,t){this.scene=e,this.camera=t,this.enabled=!0,this.clear=!0,this.needsSwap=!1,this.inverse=!1},THREE.MaskPass.prototype={render:function(e,t,o){var r=e.context;r.colorMask(!1,!1,!1,!1),r.depthMask(!1);var i,a;this.inverse?(i=0,a=1):(i=1,a=0),r.enable(r.STENCIL_TEST),r.stencilOp(r.REPLACE,r.REPLACE,r.REPLACE),r.stencilFunc(r.ALWAYS,i,4294967295),r.clearStencil(a),e.render(this.scene,this.camera,o,this.clear),e.render(this.scene,this.camera,t,this.clear),r.colorMask(!0,!0,!0,!0),r.depthMask(!0),r.stencilFunc(r.EQUAL,1,4294967295),r.stencilOp(r.KEEP,r.KEEP,r.KEEP)}},THREE.ClearMaskPass=function(){this.enabled=!0},THREE.ClearMaskPass.prototype={render:function(e){var t=e.context;t.disable(t.STENCIL_TEST)}},THREE.RenderPass=function(e,t,o,r,i){this.scene=e,this.camera=t,this.overrideMaterial=o,this.clearColor=r,this.clearAlpha=void 0!==i?i:1,this.oldClearColor=new THREE.Color,this.oldClearAlpha=1,this.enabled=!0,this.clear=!0,this.needsSwap=!1},THREE.RenderPass.prototype={render:function(e,t,o){this.scene.overrideMaterial=this.overrideMaterial,this.clearColor&&(this.oldClearColor.copy(e.getClearColor()),this.oldClearAlpha=e.getClearAlpha(),e.setClearColor(this.clearColor,this.clearAlpha)),e.render(this.scene,this.camera,o,this.clear),this.clearColor&&e.setClearColor(this.oldClearColor,this.oldClearAlpha),this.scene.overrideMaterial=null}},THREE.ShaderPass=function(e,t){this.textureID=void 0!==t?t:"tDiffuse",this.uniforms=THREE.UniformsUtils.clone(e.uniforms),this.material=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader}),this.renderToScreen=!1,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new THREE.Scene,this.quad=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),null),this.scene.add(this.quad)},THREE.ShaderPass.prototype={render:function(e,t,o){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=o),this.quad.material=this.material,this.renderToScreen?e.render(this.scene,this.camera):e.render(this.scene,this.camera,t,this.clear)}};